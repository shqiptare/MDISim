/* ~/c/MyClib/Mat6x6.h

 6x6 matrices are of special interest for machine physics, so that it makes sense to
 provide a special package for this purpose

 There is a lot on general matrix packages and linear algebra  -   only a simple subset implemented in MyClib in LinearAlgebra.h, C  and used here  for det, trace

 */

#ifndef Mat6x6_h
#define Mat6x6_h 1

#include "Vec6.h"

class Mat6x6
{
public: // class for 6*6 matrices
  // static const unsigned int nmax=6;   set in  ~/c/MyClib/Vec6.h
  unsigned int n; // the dimension, by default = Vec::ndim. Can be reduced for example to 4. Useful for tracking when t,pt handled differently
  double m[Vec::ndim][Vec::ndim]; // the first index is the row (line) and the second the column number, see colletive/Math.tex with Matrix.tex
  unsigned int verbose;
  // now the methods
  Mat6x6() { n=Vec::ndim; SetToZero(); verbose=0; }; //Stroustrup2 p. 579; constructor, allow for empty init, put all components to 0,  constructor 1
  Mat6x6(const double& m00,const double& m01,const double& m02,const double& m03,const double& m04,const double& m05,
         const double& m10,const double& m11,const double& m12,const double& m13,const double& m14,const double& m15,
         const double& m20,const double& m21,const double& m22,const double& m23,const double& m24,const double& m25,
         const double& m30,const double& m31,const double& m32,const double& m33,const double& m34,const double& m35,
         const double& m40,const double& m41,const double& m42,const double& m43,const double& m44,const double& m45,
         const double& m50,const double& m51,const double& m52,const double& m53,const double& m54,const double& m55) // constructor with definition of all matrix elements, sets also the constant nmax=6
  { n=Vec::ndim; verbose=0; // constructor 2
    m[0][0]=m00;m[0][1]=m01;m[0][2]=m02,m[0][3]=m03;m[0][4]=m04;m[0][5]=m05;
    m[1][0]=m10;m[1][1]=m11;m[1][2]=m12,m[1][3]=m13;m[1][4]=m14;m[1][5]=m15;
    m[2][0]=m20;m[2][1]=m21;m[2][2]=m22,m[2][3]=m23;m[2][4]=m24;m[2][5]=m25;
    m[3][0]=m30;m[3][1]=m31;m[3][2]=m32,m[3][3]=m33;m[3][4]=m34;m[3][5]=m35;
    m[4][0]=m40;m[4][1]=m41;m[4][2]=m42,m[4][3]=m43;m[4][4]=m44;m[4][5]=m45;
    m[5][0]=m50;m[5][1]=m51;m[5][2]=m52,m[5][3]=m53;m[5][4]=m54;m[5][5]=m55;
  };
  // http://en.wikipedia.org/wiki/Operators_in_C_and_C++,    remember the  https://en.wikipedia.org/wiki/Assignment_operator_(C++)  is default generated by the compiler
  friend Mat6x6  operator+  (const Mat6x6&,const Mat6x6&); // add two matrices
  friend Mat6x6  operator-  (const Mat6x6&,const Mat6x6&); // diff of two matrices
  friend Mat6x6  operator*  (const Mat6x6&,const Mat6x6&); // multiply two matrices
  friend Vec6    operator*  (const Mat6x6&,const Vec6&);   // multiply vector and matrix
  friend bool    operator== (const Mat6x6&,const Mat6x6&); // compare if two matrices are equal

  void inline SetDimension(unsigned int n) { if(n<=Vec::ndim) this->n=n; } // reduce the dimension, for example to 4; note however that m stays 6x6
  void inline SetToZero() { for(unsigned int i1=0;i1<n;++i1) for(unsigned int i2=0;i2<n;++i2) m[i1][i2]=0; } // vectorized
  Mat6x6 t() const;   // return the transposed (without changing the original)
  Mat6x6 SuppressSmallEntries(const double eps); // return new matrix in which all entries with abs()<eps are set to 0
  Mat6x6 y_yp(); // 2x2 matrix from by using 2-3 components, as useful to work with y,yp as x,xp

  const string Print() const; // print the matrix. On const members see Stroustrup3 p. 229
  const string Print_for_Mathematica() const; // print the matrix. On const members see Stroustrup3 p. 229

  //next also exist in more general  class Matrix
  double   det() const; // return the determinant of the matrix
  double trace() const; // return the trace of the matrix
};

Mat6x6 DiffSymplectic(const Mat6x6& M); // return the matrix giving the difference from being symplectic
bool IsSymplectic(const Mat6x6& M); // check if this matrix is symplectic

double inline trace(const Mat6x6& M) {return M.m[0][0]+M.m[1][1]+M.m[2][2]+M.m[3][3]+M.m[4][4]+M.m[5][5];}
// Mat6x6 Transpose(const Mat6x6&); // return the transposed Matrix (without changing the original)

namespace M6x6 // provide special 6x6 matrices    can be used as   M6x6::Identity,  see  ~/c/ansiitest/TestMatrix.C
// or by   using namespace M6x6; // make One, S, St available without M6x6::
{
  const Mat6x6 Identity(
                        1, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0,
                        0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 1); // Identity Matrix http://en.wikipedia.org/wiki/Identity_matrix
  // S is useful to check symplecticity
  const Mat6x6 S(
                 0, 1, 0, 0, 0, 0,
                -1, 0, 0, 0, 0, 0,
                 0, 0, 0, 1, 0, 0,
                 0, 0,-1, 0, 0, 0,
                 0, 0, 0, 0, 0, 1,
                 0, 0, 0, 0,-1, 0);
  // define a permutation of the unity matrix with rows 1-2 exchanged with 3-4. Transformation (multiplication left and right) with this swaps x,xp   <->  y, yp
  const Mat6x6 FlipXY(
                      0,0,1,0,0,0,
                      0,0,0,1,0,0,
                      1,0,0,0,0,0,
                      0,1,0,0,0,0,
                      0,0,0,0,1,0,
                      0,0,0,0,0,1);
} // namespace M6x6
#endif
